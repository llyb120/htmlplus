<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactive-Lit vs 传统方式对比</title>
    <script src="reactive-lit.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 40px;
            background: #f5f5f5;
        }
        
        .comparison-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 40px;
        }
        
        .comparison-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .card h2 {
            margin-top: 0;
            padding-bottom: 15px;
            border-bottom: 3px solid #ddd;
        }
        
        .reactive-card h2 {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .traditional-card h2 {
            color: #dc3545;
            border-bottom-color: #dc3545;
        }
        
        .code-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
        }
        
        .demo-area {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            min-height: 100px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .stats {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .stats p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .advantage {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .disadvantage {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="comparison-container">
        <h1>⚡ Reactive-Lit vs 传统 DOM 操作对比</h1>

        <!-- 对比 1: 计数器 -->
        <div class="comparison-row">
            <div class="card reactive-card">
                <h2>🚀 Reactive-Lit (响应式)</h2>
                <div class="code-section">
<pre>const [count, setCount] = createState(0);

const template = html\`
  &lt;div&gt;计数: \${count()}&lt;/div&gt;
  &lt;button onClick=\${() => setCount(count() + 1)}&gt;
    增加
  &lt;/button&gt;
\`;

render(template, container);</pre>
                </div>
                <div class="demo-area" id="reactive-counter"></div>
                <div class="advantage">
                    ✅ 优势：代码简洁，自动更新 DOM，无需手动操作
                </div>
                <div class="stats" id="reactive-counter-stats"></div>
            </div>

            <div class="card traditional-card">
                <h2>🐌 传统方式 (手动操作)</h2>
                <div class="code-section">
<pre>let count = 0;

function render() {
  container.querySelector('.count').textContent = count;
}

button.addEventListener('click', () => {
  count++;
  render(); // 必须手动调用
});</pre>
                </div>
                <div class="demo-area" id="traditional-counter"></div>
                <div class="disadvantage">
                    ❌ 劣势：需要手动调用渲染，容易遗忘，代码啰嗦
                </div>
                <div class="stats" id="traditional-counter-stats"></div>
            </div>
        </div>

        <!-- 对比 2: 表单输入 -->
        <div class="comparison-row">
            <div class="card reactive-card">
                <h2>🚀 Reactive-Lit (双向绑定)</h2>
                <div class="code-section">
<pre>const [text, setText] = createState('');

const template = html\`
  &lt;input .value=\${text()}
         onInput=\${e => setText(e.target.value)}&gt;
  &lt;p&gt;你输入了: \${text()}&lt;/p&gt;
  &lt;p&gt;长度: \${text().length}&lt;/p&gt;
\`;

render(template, container);</pre>
                </div>
                <div class="demo-area" id="reactive-input"></div>
                <div class="advantage">
                    ✅ 优势：响应式更新，代码清晰，易于理解
                </div>
            </div>

            <div class="card traditional-card">
                <h2>🐌 传统方式 (手动同步)</h2>
                <div class="code-section">
<pre>let text = '';

input.addEventListener('input', (e) => {
  text = e.target.value;
  // 手动更新所有依赖此数据的 DOM
  textDisplay.textContent = '你输入了: ' + text;
  lengthDisplay.textContent = '长度: ' + text.length;
});</pre>
                </div>
                <div class="demo-area" id="traditional-input"></div>
                <div class="disadvantage">
                    ❌ 劣势：每次都要手动更新多个 DOM 节点，容易遗漏
                </div>
            </div>
        </div>

        <!-- 对比 3: 列表渲染 -->
        <div class="comparison-row">
            <div class="card reactive-card">
                <h2>🚀 Reactive-Lit (自动列表更新)</h2>
                <div class="code-section">
<pre>const state = reactive({ items: ['A', 'B', 'C'] });

const template = html\`
  &lt;ul&gt;
    \${state.items.map(item => 
      html\`&lt;li&gt;\${item}&lt;/li&gt;\`
    ).join('')}
  &lt;/ul&gt;
  &lt;button onClick=\${() => 
    state.items.push('New')
  }&gt;添加&lt;/button&gt;
\`;</pre>
                </div>
                <div class="demo-area" id="reactive-list"></div>
                <div class="advantage">
                    ✅ 优势：数组操作后自动更新，无需关心 DOM 细节
                </div>
            </div>

            <div class="card traditional-card">
                <h2>🐌 传统方式 (手动列表管理)</h2>
                <div class="code-section">
<pre>let items = ['A', 'B', 'C'];

function renderList() {
  ul.innerHTML = ''; // 清空
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    ul.appendChild(li);
  });
}

button.addEventListener('click', () => {
  items.push('New');
  renderList(); // 手动重新渲染
});</pre>
                </div>
                <div class="demo-area" id="traditional-list"></div>
                <div class="disadvantage">
                    ❌ 劣势：完全重建 DOM，性能差，代码繁琐
                </div>
            </div>
        </div>

        <!-- 对比 4: 复杂状态 -->
        <div class="comparison-row">
            <div class="card reactive-card">
                <h2>🚀 Reactive-Lit (计算属性)</h2>
                <div class="code-section">
<pre>const state = reactive({
  items: [
    { name: '苹果', price: 5, qty: 2 },
    { name: '香蕉', price: 3, qty: 3 }
  ]
});

const total = computed(() =>
  state.items.reduce((sum, item) => 
    sum + item.price * item.qty, 0
  )
);

const template = html\`
  &lt;div&gt;总价: \${total()}&lt;/div&gt;
\`;</pre>
                </div>
                <div class="demo-area" id="reactive-computed"></div>
                <div class="advantage">
                    ✅ 优势：计算属性自动缓存和更新，高效且简洁
                </div>
            </div>

            <div class="card traditional-card">
                <h2>🐌 传统方式 (手动计算)</h2>
                <div class="code-section">
<pre>let items = [
  { name: '苹果', price: 5, qty: 2 },
  { name: '香蕉', price: 3, qty: 3 }
];

function calculateTotal() {
  return items.reduce((sum, item) => 
    sum + item.price * item.qty, 0
  );
}

function updateDisplay() {
  const total = calculateTotal();
  totalEl.textContent = '总价: ' + total;
}</pre>
                </div>
                <div class="demo-area" id="traditional-computed"></div>
                <div class="disadvantage">
                    ❌ 劣势：每次都要手动计算和更新，无缓存
                </div>
            </div>
        </div>
    </div>

    <script>
        const { html, render, reactive, computed, createComponent, createState } = window.ReactiveLit;

        // ========== Reactive-Lit 示例 ==========

        // 1. 响应式计数器
        createComponent(() => {
            const [count, setCount] = createState(0);
            const [updates, setUpdates] = createState(0);
            
            const increment = () => {
                setCount(count() + 1);
                setUpdates(updates() + 1);
            };
            
            const template = html`
                <div style="text-align: center;">
                    <h3 style="font-size: 2em; color: #667eea;">${count()}</h3>
                    <button onClick=${increment}>➕ 增加</button>
                    <button onClick=${() => { setCount(0); setUpdates(updates() + 1); }}>🔄 重置</button>
                </div>
            `;
            
            render(template, document.getElementById('reactive-counter'));
            
            document.getElementById('reactive-counter-stats').innerHTML = `
                <p><strong>渲染次数:</strong> ${updates()}</p>
                <p><strong>代码行数:</strong> ~10 行</p>
                <p><strong>性能:</strong> ⚡ 只更新变化的部分</p>
            `;
        }, document.getElementById('reactive-counter'));

        // 2. 响应式输入
        createComponent(() => {
            const [text, setText] = createState('');
            
            const template = html`
                <div>
                    <input 
                        type="text" 
                        placeholder="输入一些文字..."
                        .value=${text()}
                        onInput=${(e) => setText(e.target.value)}
                    />
                    <p><strong>你输入了:</strong> ${text() || '(空)'}</p>
                    <p><strong>字符长度:</strong> ${text().length}</p>
                    <p><strong>单词数:</strong> ${text().trim().split(/\s+/).filter(w => w).length}</p>
                </div>
            `;
            
            render(template, document.getElementById('reactive-input'));
        }, document.getElementById('reactive-input'));

        // 3. 响应式列表
        createComponent(() => {
            const state = reactive({
                items: ['项目 A', '项目 B', '项目 C']
            });
            
            const addItem = () => {
                state.items.push(`项目 ${String.fromCharCode(65 + state.items.length)}`);
            };
            
            const removeItem = () => {
                if (state.items.length > 0) {
                    state.items.pop();
                }
            };
            
            const template = html`
                <div>
                    <ul style="list-style: none; padding: 0;">
                        ${state.items.map((item, i) => html`
                            <li style="background: #667eea; color: white; padding: 8px; margin: 5px 0; border-radius: 4px;">
                                ${i + 1}. ${item}
                            </li>
                        `).join('')}
                    </ul>
                    <button onClick=${addItem}>➕ 添加项目</button>
                    <button onClick=${removeItem}>➖ 删除最后一项</button>
                    <p style="margin-top: 10px;"><strong>总计:</strong> ${state.items.length} 项</p>
                </div>
            `;
            
            render(template, document.getElementById('reactive-list'));
        }, document.getElementById('reactive-list'));

        // 4. 响应式计算属性
        createComponent(() => {
            const state = reactive({
                items: [
                    { name: '苹果', price: 5, qty: 2 },
                    { name: '香蕉', price: 3, qty: 3 }
                ]
            });
            
            const total = computed(() => {
                return state.items.reduce((sum, item) => sum + item.price * item.qty, 0);
            });
            
            const updateQty = (index, delta) => {
                state.items[index].qty = Math.max(0, state.items[index].qty + delta);
            };
            
            const template = html`
                <div>
                    ${state.items.map((item, i) => html`
                        <div style="background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 6px;">
                            <strong>${item.name}</strong> - ¥${item.price} x ${item.qty}
                            <button onClick=${() => updateQty(i, -1)}>-</button>
                            <button onClick=${() => updateQty(i, 1)}>+</button>
                        </div>
                    `).join('')}
                    <div style="background: #667eea; color: white; padding: 15px; border-radius: 6px; text-align: center;">
                        <h3 style="margin: 0;">总价: ¥${total()}</h3>
                    </div>
                </div>
            `;
            
            render(template, document.getElementById('reactive-computed'));
        }, document.getElementById('reactive-computed'));

        // ========== 传统方式示例 ==========

        // 1. 传统计数器
        {
            const container = document.getElementById('traditional-counter');
            let count = 0;
            let updates = 0;
            
            function renderCounter() {
                updates++;
                container.innerHTML = `
                    <div style="text-align: center;">
                        <h3 style="font-size: 2em; color: #dc3545;">${count}</h3>
                        <button id="trad-inc">➕ 增加</button>
                        <button id="trad-reset">🔄 重置</button>
                    </div>
                `;
                
                document.getElementById('trad-inc').addEventListener('click', () => {
                    count++;
                    renderCounter();
                    updateStats();
                });
                
                document.getElementById('trad-reset').addEventListener('click', () => {
                    count = 0;
                    renderCounter();
                    updateStats();
                });
            }
            
            function updateStats() {
                document.getElementById('traditional-counter-stats').innerHTML = `
                    <p><strong>渲染次数:</strong> ${updates}</p>
                    <p><strong>代码行数:</strong> ~20 行</p>
                    <p><strong>性能:</strong> 🐌 完全重建 DOM</p>
                `;
            }
            
            renderCounter();
            updateStats();
        }

        // 2. 传统输入
        {
            const container = document.getElementById('traditional-input');
            let text = '';
            
            container.innerHTML = `
                <div>
                    <input type="text" id="trad-input" placeholder="输入一些文字..." />
                    <p id="trad-text"><strong>你输入了:</strong> (空)</p>
                    <p id="trad-length"><strong>字符长度:</strong> 0</p>
                    <p id="trad-words"><strong>单词数:</strong> 0</p>
                </div>
            `;
            
            document.getElementById('trad-input').addEventListener('input', (e) => {
                text = e.target.value;
                // 必须手动更新每个 DOM 元素
                document.getElementById('trad-text').innerHTML = 
                    `<strong>你输入了:</strong> ${text || '(空)'}`;
                document.getElementById('trad-length').innerHTML = 
                    `<strong>字符长度:</strong> ${text.length}`;
                document.getElementById('trad-words').innerHTML = 
                    `<strong>单词数:</strong> ${text.trim().split(/\s+/).filter(w => w).length}`;
            });
        }

        // 3. 传统列表
        {
            const container = document.getElementById('traditional-list');
            let items = ['项目 A', '项目 B', '项目 C'];
            
            function renderList() {
                const ul = document.createElement('ul');
                ul.style.cssText = 'list-style: none; padding: 0;';
                
                items.forEach((item, i) => {
                    const li = document.createElement('li');
                    li.style.cssText = 'background: #dc3545; color: white; padding: 8px; margin: 5px 0; border-radius: 4px;';
                    li.textContent = `${i + 1}. ${item}`;
                    ul.appendChild(li);
                });
                
                container.innerHTML = '';
                container.appendChild(ul);
                
                const addBtn = document.createElement('button');
                addBtn.textContent = '➕ 添加项目';
                addBtn.onclick = () => {
                    items.push(`项目 ${String.fromCharCode(65 + items.length)}`);
                    renderList();
                };
                
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '➖ 删除最后一项';
                removeBtn.onclick = () => {
                    if (items.length > 0) {
                        items.pop();
                        renderList();
                    }
                };
                
                const p = document.createElement('p');
                p.style.marginTop = '10px';
                p.innerHTML = `<strong>总计:</strong> ${items.length} 项`;
                
                container.appendChild(addBtn);
                container.appendChild(removeBtn);
                container.appendChild(p);
            }
            
            renderList();
        }

        // 4. 传统计算属性
        {
            const container = document.getElementById('traditional-computed');
            let items = [
                { name: '苹果', price: 5, qty: 2 },
                { name: '香蕉', price: 3, qty: 3 }
            ];
            
            function calculateTotal() {
                return items.reduce((sum, item) => sum + item.price * item.qty, 0);
            }
            
            function renderComputed() {
                container.innerHTML = '';
                
                items.forEach((item, i) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 6px;';
                    
                    const text = document.createElement('span');
                    text.innerHTML = `<strong>${item.name}</strong> - ¥${item.price} x ${item.qty} `;
                    
                    const minusBtn = document.createElement('button');
                    minusBtn.textContent = '-';
                    minusBtn.onclick = () => {
                        items[i].qty = Math.max(0, items[i].qty - 1);
                        renderComputed();
                    };
                    
                    const plusBtn = document.createElement('button');
                    plusBtn.textContent = '+';
                    plusBtn.onclick = () => {
                        items[i].qty++;
                        renderComputed();
                    };
                    
                    div.appendChild(text);
                    div.appendChild(minusBtn);
                    div.appendChild(plusBtn);
                    container.appendChild(div);
                });
                
                const totalDiv = document.createElement('div');
                totalDiv.style.cssText = 'background: #dc3545; color: white; padding: 15px; border-radius: 6px; text-align: center;';
                totalDiv.innerHTML = `<h3 style="margin: 0;">总价: ¥${calculateTotal()}</h3>`;
                container.appendChild(totalDiv);
            }
            
            renderComputed();
        }
    </script>
</body>
</html>

